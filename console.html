<!doctype html>
<html>
<head>
<style type="text/css">
html, body {
	width: 100%;
	height: 100%;
	padding: 0;
	margin: 0;
	background-color: #111;
	color: #eee;
	cursor: none;
}
#console_area {
	padding: 0;
	margin: 0;
	background-color: #111;
	color: #eee;
	font-size: 10pt;
	font-family: "Courier New";
	white-space: pre;
	vertical-align: top;
}
#console_input_line {
	width: 100%;
    padding: 0;
	margin: 0;
	background-color: #111;
	display: table;
	border: 0 none #000;
	border-collapse: collapse;
	border-spacing: 0;
	line-height: 1;
}
#console_prompt {
	vertical-align: top;
	width: 1px;
    padding: 0;
	margin: 0;
	background-color: #111;
	color: #eee;
	font-size: 10pt;
	font-family: "Courier New";
	white-space: pre;
	display: table-cell;
	border: 0 none #000;
	line-height: 1;
}
#console_input {
	vertical-align: top;
	width: 100%;
	/* height: 100%; */
	display: table-cell;
	background-color: #111;
	color: #eee;
	font-size: 10pt;
	font-family: "Courier New";
	border: 0 none #000;
	outline: 0;
	padding: 0;
	margin: 0;
	line-height: 1;
}
</style>
<script>

var 

lisp_fns = {
	"+": function (args) {
		var	rtn = 0; // CLISP returns 0 if `+` is given no arguments.
		while (args.length) {
			rtn += args.shift();
		};
		return rtn;
	},
	"-": function (args) {
		var rtn = args.shift();
		while (args.length) {
			rtn -= args.shift();
		};
		return rtn;
	},
	"*": function (args) {
		var rtn = 1; // CLISP returns 1 if `*` is given no arguments.
		while (args.length) {
			rtn *= args.shift();
		};
		return rtn;
	},
	"/": function (args) {
		var rtn = args.shift();
		while (args.length) {
			rtn /= args.shift();
		}
		return rtn;
	}
},

command_log = (function () {
	var cmd_log = [],
		cmd_key = 0,
		cmd_num = 0,
		cmd_cache = "",
		add_cmd = function (cmd) {
			cmd_log.push(cmd);
			cmd_key = cmd_log.length;
			cmd_cache = "";
			return cmd;
		},
		cache_cmd = function (cmd) {
			cmd_cache = cmd;
			return cmd;
		},
		get_curr_prompt = function () {
			return "[" + cmd_num + "]> ";
		},
		get_next_prompt = function () {
			cmd_num += 1;
			return "[" + cmd_num + "]> ";
		},
		get_prev_cmd = function () {
			cmd_key -= (cmd_key) ? 1 : 0;
			return cmd_log[cmd_key];
		},
		get_next_cmd = function () {
			cmd_key += (cmd_key < cmd_log.length) ? 1 : 0;
			return (cmd_key < cmd_log.length) ? cmd_log[cmd_key] : cmd_cache;
		};
	return {
		add_cmd: add_cmd,
		cache_cmd: cache_cmd,
		get_curr_prompt: get_curr_prompt,
		get_next_prompt: get_next_prompt,
		get_prev_cmd: get_prev_cmd,
		get_next_cmd: get_next_cmd
	};
})(),

separate_terms = function (input) {
	var str = input,
		arr = [],
		rst = "",
		rex = /(\s+)|(")|(\()|(\))|(.$)/g,
		begin_term = 0,
		end_term = 0,
		paren_level = 0,
		quote_level = false,
		rfn = function ($m, $1, $2, $3, $4, $5, offset, whole_string) {
			var out;
			if ($2 && !paren_level) {
				console.log(quote_level);
				quote_level = !quote_level;
				if (quote_level) {
					begin_term = offset;
				} else {
					end_term = offset + $m.length;
					out = whole_string.slice(begin_term, end_term);
					console.log(end_term);
					console.log(out);
					begin_term = end_term;
				}
			} else if ($3 && !quote_level) {
				paren_level += 1;
				if (!paren_level) {
					begin_term = offset;
				}
			} else if ($4 && !quote_level) {
				paren_level -= 1;
				if (!paren_level) {
					end_term = offset + $m.length;
					out = whole_string.slice(begin_term, end_term);
					begin_term = end_term;
				}
			} else if ($1 && !paren_level && !quote_level) {
				end_term = offset;
				out = whole_string.slice(begin_term, end_term);
				begin_term = end_term + $m.length;
			} else if ($5 && !quote_level) {
				end_term = whole_string.length;
				out = whole_string.slice(begin_term, end_term);
				begin_term = end_term + $m.length;
			}
			
			if (out) { arr.push(out); };
			return $m;
		};

	rst = str.replace(rex, rfn);
	return arr;
},

evaluate_term = function (term) {
	var rtn,
		arr,
		fun,
		arg = [];
	if (/\D/g.test(term)) {
		if (/^\(.*\)$/.test(term)) {
			if (term.slice(1, -1)) {
				arr = separate_terms(term.slice(1, -1));
				fun = arr.shift();
				while (arr.length) {
					arg.push(evaluate_term(arr.shift()));
				}
				if (lisp_fns.hasOwnProperty(fun)) {
					rtn = lisp_fns[fun](arg);
				} else {
					// TODO: What if there is no such function?
				}
			} else {
				// If parentheses are empty.
				rtn = "NIL";
			}
		} else if (/^".*"$/g.test(term)) {
			console.log(term);
			rtn = term;
		}
	} else {
		rtn = +term;
	}
	return rtn;
},

process_input = function (input) {
	var rtn,
		arr = separate_terms(input),
		rst;
	
	while (arr.length) {
		update_console(command_log.get_curr_prompt() + input);
		input = "";
		rst = evaluate_term(arr.shift());
		update_console(rst);
		prompt_set(command_log.get_next_prompt());
	}
	
	return rtn;
},

update_console = function (value) {
	document.getElementById("console_area").innerHTML += value;
	document.getElementById("console_area").innerHTML += "<br>";
},

prompt_set = function (value) {
	document.getElementById("console_prompt").innerHTML = value;
}

input_get = function () {
	return document.getElementById("console_input").value;
},

input_set = function (value) {
	document.getElementById("console_input").value = value;
},

window.onload = function () {
	prompt_set(command_log.get_next_prompt());
	document.getElementById("console_input").focus();
	document.getElementById("console_input").onkeyup = function (k) {
		var e = k || window.event,
			input = input_get(); // for IE8
		if (e.keyCode === 13) {
			input_set("");
			command_log.add_cmd(input);
			process_input(input);
		} else if (e.keyCode === 38) {
			// up
			input_set(command_log.get_prev_cmd() || "");
		} else if (e.keyCode === 40) {
			// down
			input_set(command_log.get_next_cmd() || "");
		} else {
			command_log.cache_cmd(input);
		}
	};
};

</script>
</head>
<body>
<div id="console_area">
 i i i i i i i
 I I I I I I I
 I  \ `+´ /  I
  \  `-+-´  /
   `-__|__-´
       |
 ------+------
</div>
<div id="console_input_line">
<div id="console_prompt"></div>
<input id="console_input"></input>
</div>
</body>
</head>
</html>